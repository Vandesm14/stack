'(fn! read-file parse call) 'import set
'(fn false =) 'not set

;; Let
;; ========================================

;; Creates a let block
;; {list(fn ...) list(vars)} -> {list(fn ...)}
'(fn
  ['vars set]
  ['func set]

  ['vars get len] ['var-len set]


  ['() 'new-fn set]

  ['func get]
  [list-shift dup typeof]
  ["fn" =]

  '(
    ;; Insert the `fn` call into the new function (preserving metadata)
    ['new-fn get swap insert]
    ['new-fn set]

    ;; list-shift gives us the item and the list
    ;; We want to update `func` to not include the `fn` call
    ;; if it has it
    ['func set]
) '(
  ;; Pulls from the equal check above the `if` statement
) if

  [0 'i set]

  '(
    ;; Get the new function
    ['new-fn get]

    ;; Get the vars
    [vars]

    ;; Index of the next var in reverse
    [[var-len 1 -] i -]

    ;; Get the nth item, make it lazy, and insert it
    [nth lazy insert]

    ;; Insert a `set` call
    ['set insert]

    ;; Update our new-fn
    ['new-fn set]

    [i 1 + 'i set]
  )
  '(i var-len <)
  while

  ['new-fn get]
  ['func get]
  concat
) 'let-fn set

;; QoL function to auto-call the created let block
;; {list(fn ...) list(vars)} -> {}
'(fn! let-fn call) 'let set

;; QoL function to set a let block to a variable
;; {list(fn ...) list(vars) symbol} -> {}
'(fn!
  ;; Creating a scoped function to keep `func`, `vars`, and `symbol` private
  '(fn
    ['func get]
    ['vars get]
    let-fn

    symbol
    ;; Returning {list(fn ...) symbol}
  ) '(func vars symbol) let

  ;; Setting the function to the symbol in the current scope
  set
) 'defn set

;; Modules
;; ========================================
'(fn!
  dup
  get

  '()
  [swap insert]
  [swap insert]
  [insert]
) 'export set

;; Run this function within the same scope
'(fn!
  ;; Create a template function that will be used to set all of the imported variables
  ;; in the current scope
  '(fn!)

  ;; Create a let block to bring in our args
  '(fn
    "std/list.stack" import

    ['namespace get]
    ['runner get]
    ['scope get]

    ;; Create a let block for the for_each loop
    '(fn
      ['runner get]
      ['item get]

      ;; Set the first item to be lazy so that it is not evaluated
      [unwrap swap lazy]
      ;; Reconstruct the pair
      ['() swap insert swap insert]

      ;; Pop the symbol from the export {(val symbol)} -> {(val) symbol}
      ;; Turn it into a string then into a list of chars
      [list-pop tostring explode]

      ;; Turn the namespace into a string then into a list of chars
      ;; Add a "/" to the end of the namespace
      ['namespace get tostring explode "/" insert]
      [swap]

      ;; Join the namespace and the symbol
      [concat "" join]

      ;; Push the item as a lazy symbol to the set code
      [tocall lazy insert]

      ;; Push a `'set` call to the code
      ['set insert]

      ;; Add the code to the template function and update it
      [concat 'runner set]

      ;; Put the namespace and runner back on the stack
      'namespace get
      'runner get
    ) '(namespace runner item) let-fn
    list/for_each
  ) '(scope namespace runner) let

  ;; Call our template function to set all of the imported variables
  call

  ;; Pop namespace
  pop
) 'use set

;; Run this function within the same scope
'(fn!
  ;; Create a template function that will be used to set all of the imported variables
  ;; in the current scope
  '(fn!)

  ;; Create a let block to bring in our args
  '(fn
    "std/list.stack" import

    ['runner get]
    ['scope get]

    ;; Create a let block for the for_each loop
    '(fn
      ['runner get]
      ['item get]

      ;; Set the first item to be lazy so that it is not evaluated
      [unwrap swap lazy]
      ;; Reconstruct the pair
      ['() swap insert swap insert]

      ;; Push the item as a lazy symbol to the set code
      [list-pop lazy insert]

      ;; Push a `'set` call to the code
      ['set insert]

      ;; Add the code to the template function and update it
      [concat 'runner set]

      ;; Put the runner back on the stack
      'runner get
    ) '(runner item) let-fn
    list/for_each
  ) '(scope runner) let

  ;; Call our template function to set all of the imported variables
  call
) 'use-all set